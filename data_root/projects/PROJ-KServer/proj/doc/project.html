<html>
  <p>The <b>k-server problem</b> is a problem of <a href="/wiki/Theoretical_computer_science" title="Theoretical computer science">theoretical computer science</a> in the category of  <a href="/wiki/Online_algorithm" title="Online algorithm">online algorithms</a>, one of two abstract problems on <a href="/wiki/Metric_space" title="Metric space">metric spaces</a> that are central to the theory of <a href="/wiki/Competitive_analysis_(online_algorithm)" title="Competitive analysis (online algorithm)">competitive analysis</a> (the other being <a href="/wiki/Metrical_task_systems" class="mw-redirect" title="Metrical task systems">metrical task systems</a>). In this problem, an online algorithm must control the movement of a set of <i>k</i> <i>servers</i>, represented as points in a metric space, and handle <i>requests</i> that are also in the form of points in the space. As each request arrives, the algorithm must determine which server to move to the requested point. The goal of the algorithm is to keep the total distance all servers move small, relative to the total distance the servers could have moved by an optimal adversary who knows in advance the entire sequence of requests.
</p>

<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket"></h3>
<p>To make the problem more concrete, imagine sending customer support technicians to customers when they have trouble with their equipment. In our example problem there are two technicians, Mary and Noah, serving three customers, in San Francisco, California; Washington, DC; and Baltimore, Maryland. As a <i>k</i>-server problem, the servers are the technicians, so <i>k</i> = 2 and this is a 2-server problem. Washington and Baltimore are 35 miles (56&#160;km) apart, while San Francisco is 3,000 miles (4,800&#160;km) away from both, and initially Mary and Noah are both in San Francisco.
</p><p>Consider an algorithm for assigning servers to requests that always assigns the closest server to the request, and suppose that each weekday morning the customer in Washington needs assistance while each weekday afternoon the customer in Baltimore needs assistance, and that the customer in San Francisco never needs assistance. Then, our algorithm will assign one of the servers (say Mary) to the Washington area, after which she will always be the closest server and always be assigned to all customer requests. Thus, every day our algorithm incurs the cost of traveling between Washington and Baltimore and back, 70 miles (110&#160;km). After a year of this request pattern, the algorithm will have incurred 20,500 miles (33,000&#160;km) travel: 3000 to send Mary to the East Coast, and 17,500 for the trips between Washington and Baltimore. On the other hand, an optimal adversary who knows the future request schedule could have sent both Mary and Noah to Washington and Baltimore respectively, paying 6,000 miles (9,700&#160;km) of travel once but then avoiding any future travel costs. The competitive ratio of our algorithm on this input is 20,500/6000 or approximately 3.4, and by adjusting the parameters of this example the competitive ratio of this algorithm can be made arbitrarily large.
</p><p>Thus we see that always assigning the closest server can be far from optimal. On the other hand, it seems foolish for an algorithm that does not know future requests to send both of its technicians away from San Francisco, as the next request could be in that city and it would have to send someone back immediately. So it seems that it is difficult or impossible for a <i>k</i>-server algorithm to perform well relative to its adversary. However, for the 2-server problem there exists an algorithm that always has a total travel distance of at most twice the adversary's distance.
The <i>k</i>-server conjecture states that similar solutions exist for problems with any larger number of technicians.
</p>

<h3>Measuring effectiveness</h3>
<p> As previously mentioned the only objective way to measure the performance of an algorithm is by comparing it's solution with the solution of an ideal optimal algorithm which knows the sequence of requests in advance. We call this factor ρ and have used it extensively in the project. </p>
<h4>ρ = cost(solution) / cost(optimal solution)</h4>
</br>
<h4> Refferences: </h4>
1. <a href="https://en.wikipedia.org/wiki/K-server_problem">Wikipedia - K-server problem</a>

</html>
